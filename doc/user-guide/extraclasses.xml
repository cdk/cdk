<chapter>
    <title>Extra Classes</title>

    <section> 
      <title>The Tools</title> 
      <para>
        The tools classes are located in the org.openscience.cdk.tools and a few
        other packages. 
        The tools package contains everything for which the creation of an own subpackage 
        could not be justified. Some of them might be moved to their own subpackages later
        as soon as more classes acting in this particular field have been created. 
        Often used tools are:
        <itemizedlist>
           <listitem>
             <para>
               &config.AtomTypeFactory;, a class generating
               AtomContraints containing informations like maximum
               allowed bond orders for certain chemical elements. Those
               AtomConstraints are used for example in structure
               generators. 
             </para>
           </listitem>
           <listitem>
             <para>
               &graph.ConnectivityChecker;, a class that checks if an
               AtomContainer is connected, that is if there is a path
               from each atom to each other atom in the molecule. The
               class also has a method for partitioning an
               AtomContainer into the connected graphs it contains.
             </para>
           </listitem>
           <listitem>
             <para>
               &tools.HOSECodeGenerator;
               generates HOSECodes for atoms in a
               molecule. HOSE stands for Hierarchically Ordered
               Spherical Environment and is a method for describing the
               environment of an atom. It is mostly used in the
               prediction of carbon NMR. 
             </para>
           </listitem>
           <listitem>
             <para>
               &config.IsotopeFactory;, produces Isotopes for a given ElementSymbol, based on 
               an XML configuration file in org/openscience/cdk/config
             </para>
           </listitem>
           <listitem>
             <para>
               &tools.SwissArmyKnife;
               is an allround tools for methods that
               really didn't fit into anything else. I'm not sure if
               there is any justification for such a class or if it is
               not better to create a new class for each purpose even
               if is only has one method. 
             </para>
           </listitem>
        </itemizedlist>
      </para>
    </section>

    <section> 
        <title>The Structure Generator Classes</title> 
        <para> The Structure Generator classes are located in the org.openscience.cdk.structgen package. 
        They are related to generating constitutional isomers for a given
        molecular formula, often obeying certain contraints. 
        <itemizedlist>
            <listitem>
                <para>
                &structgen.RandomGenerator;:
                This structure generator makes small random moves in
                structure space, starting from a given constitutional
                formula, which might be generated using 
                &structgen.SingleStructureRandomGenerator;.
                It does this by randomly choosing four atoms and
                breaking old and forming new bonds according to rules
                defined in <ulink url="biblio.html#FAU96"/>.
                </para>
            </listitem>
            <listitem>
                <para>
                &structgen.SingleStructureRandomGenerator;:
                Randomly generates a single, connected, correctly bonded structure for 
                a given molecular formula
                To see it working run the graphical 
                test org.openscience.cdk.test.SingleStructureRandomGeneratorTest
                and add more structures to the panel using the "More" button. 
                In order to use this class, use MFAnalyser to get an AtomContainer from 
                a molecular formula string.
                Assign hydrogen counts to each heavy atom. The hydrogens should not be
                in the atom pool but should be assigned implicitly to the heavy atoms in 
                order to reduce computational cost.
                Assign this AtomContainer to the  
                SingleStructureRandomGenerator and retrieve a randomly generated, but correctly bonded
                structure by using the generate() method. You can then repeatedly call
                the generate() method in order to retrieve further structures. 
                </para>
            </listitem>		
        </itemizedlist>
        </para>
    </section>

    <section>
    <title>Introduction from the handling of orbitals</title>
    <section>
        <title>Basics</title>
        <para>
        An orbital were handled through a vector and a basis set. The
        elements were the coefficients for the basis set. A example
        for a basis set are the gauss functions
        </para>
        <para>
        basis_i(x,y,z) = C_i * (x_i - x)^nx_i *  (y_i - y)^ny_i * (z_i - z)^nz_i *
        exp(-alpha * (x_i - x)^2 * (y_i - y)^2 * (z_i - z)^2)
        r_i = [x_i , y_i , z_i]
        </para>
        <para>
        The class GaussiansBasis will used to calculates the basis. For 
        example, we want construct a px, py and a pz-Orbital. The coefficient
        for the basis are nx=[1,0,0], ny=[0,1,0], nz=[0,0,1]. Was the position
        of these orbitals at the center of an atom, were x_i,y_i,z_i the
        coordinates of the atom.
        </para>
        <programlisting>
        int[] nx = new int[3]{1,0,0};
        int[] ny = new int[3]{0,1,0};
        int[] ny = new int[3]{0,0,1};
        double[] alpha = new double[3]{1d,1d,1d};
        Vector[] r = new Vector[3]{new Vector(atom.getPoint3D())
                                    new Vector(atom.getPoint3D())
                                    new Vector(atom.getPoint3D())};
        Atom[] atoms = new Atom[]{atom};

        GaussiansBasis basis = new GaussiansBasis(nx,ny,nz,alpha,r,atoms);
        </programlisting>
        <para>
        For the declaration of the orbitals we need the coefficients for the
        basis. The px Orbital got the vector O_1=[1,0,0], the py Orbital O_2=[0,1,0]
        and the pz orbital O_3=[0,0,1]
        </para>
        <para>
        f_i(x,y,z) = O_i * basis_i
        </para>
        <para>
        The class orbitals used to store the coefficients. The class stores the
        coefficients in a matrix. Each column are a orbital.
        </para>
        <programlisting>
        Matrix coeff = new Matrix(new double[][]
            {
            {1d, 0d, 0d},
            {0d, 1d, 0d},
            {0d, 0d, 1d}
            });
        Orbitals orbitals = new Orbitals(basis, coeff);
        </programlisting>
        <para>
        To render the orbitals we could use the AcceleratedRenderer3D
        </para>
        <programlisting>
        int currentorbital = 0;
        AcceleratedRenderer3DModel model = new AcceleratedRenderer3DModel(orbitals, currentorbital);
        AcceleratedRenderer3D renderer = new AcceleratedRenderer3D(model);

        frame.add(renderer, BorderLayout.CENTER);
        </programlisting>
    </section>
  </section>
  
  <section>
    <title>Validation</title>
    <para>
      It is often useful to test chemical content against a number of rules.
      E.g. is the formal charge on the atom realistic, or do the four neighbours of
      a carbon (approximately) form a tetrahedral shape. CDK's validation package
      automizes such testing.
    </para>
    <section>
      <title>The ValidatorEngine</title>
      <para>
        The &validate.ValidatorEngine; can be used to automize the process of validation.
        A new engine can be constructed with:
        <programlisting>
ValidatorEngine engine = new ValidatorEngine();
        </programlisting>
        The next step is to tell the engine which tests should be performed.
        CDK, at this moment, contains a few classes that define sets of test. A set
        can be added to the validator with:
        <programlisting>
engine.addValidator(new BasicValidator());
        </programlisting>
        The &validate.BasicValidator; tests for basic chemical assumptions like unlike
        formal charges. A full list can be found in the JavaDoc documentation of the class.
      </para>
      <para>
        Running the validation test is then done with:
        <programlisting>
ValidationReport report = engine.validateMolecule(new Molecule());
        </programlisting>
        which returns a &validate.ValidationReport;.
      </para>
    </section>
    <section>
      <title>Making custom validation tests</title>
      <para>
        The ValidationEngine.addValidator() method takes an object of a class
        that implements the &validate.ValidatorInterface;. Thus, custom validation
        tests can easily be made by building a class that implements this interface,
        and registering it with the engine. Ofcourse, the existing BasicValidator
        source code can be used as a starting point.
      </para>
    </section>
  </section>

</chapter>
